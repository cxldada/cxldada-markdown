---
title: 0. Unix环境高级编程
date: 2020-07-16 08:13:25
categories: Unix
tag: unix
---

## Unix环境高级编程

从这篇文章开始记录学习《Unix环境高级编程》这本书的一些知识点。
后面在结合《深入理解操作系统原理》一起，系统的学习系统应用的开发

<!--more-->

## Unix体系结构
所有的操作系统都为他们所运行的程序提供服务，最典型的服务器包括：执行新程序、打开文件、读文件、分配存储空间以及获取当前时间等等。
操作系统可以定义为一种软件，它控制着计算的硬件资源，提供程序运行环境。
因为操作系统这种软件比较小，而且位于环境的核心，所以我们称之为内核。

## 文件和目录
unix文件系统是目录和文件的一种层次结构，所有的东西的起点是称为根的目录 -- ‘/’
对文件的操作是unix系统编程的一个重点

## 输入输出

不带缓冲的IO函数：`open`、`read`、`write`、`lseek`、`close`
标准IO：
1. 为不带缓冲的IO函数提供一个带缓冲的接口。
2. 无需担心如何选取最佳的缓冲区大小
3. 简化了对输入行的处理

IO操作是unix环境编程的重点之一

## 程序和进程

1. 程序的执行实例被称为进程。UNIX系统确保每个进程都有一个唯一的数字标识符，称为进程ID，进程ID总是一个非负整数
2. 有三个用于进程控制的函数：`fork`、`exec`和`waitpid`。(exec函数有7种变体，但是经常统称为exec函数)
3. 线程是指进程中某一时刻执行的一组机器指令，通常一个进程只有一个控制线程。
   * 进程内的所有线程共享同一地址空间、文件描述符、栈以及与进程相关的属性。
   * 因为线程可以访问同一存储区，所有在处理多线程问题时要注意共享数据的同步问题
   * 同进程一样线程也有ID标识。但是线程ID只在它所属的进程中有效。

## 出错处理

1. 当Unix系统函数出错时，通常会返回一个负值，而且整型变量`errno`通常被设置为具有特定信息的值。

2. 有些函数对于出错则使用另一种约定而不是返回负值。例如，大多数返回对象指针的函数，出错时通常返回`NULL`指针

3. 文件`<errno.h>`中定义了`errno`以及可以赋予它的各种常量。

4. 在支持线程的环境中，每个线程都有属于它自己的局部`errno`，以避免一个线程干扰另一个线程

5. 对于`errno`要注意两条规则：

   * 如果没有出错，其值不会被例程清除。因此仅当函数的返回值明确指出错误时，才检测其值
   * 任何函数都不会将`errno`值设置为0，而且在`errno.h`中定义的所有常量都不为0

6. c标准定义了两个函数，用于打印出错信息

   ```c
   #include <string.h>
   // 用于将errnum(通常是errno)映射为一个出错信息字符串，并返回字符串指针
   char *strerror(int errnum);
   
   #include <stdio.h>
   // 给予errno当前值，在标准错误上产生一条出错信息，并返回
   void perror(const char *msg); // 先打印参数msg然后加一个冒号和一个空格，然后是errno对应的错误信息，最后是一个换行符
   ```

7. `errno.h`中定义的各种出错分为两类：

   * 致命性错误：无法执行恢复动作，最多打印一条出错信息写入日志文件中
   * 非致命性错误：有时可以经过妥善的处理让程序恢复运行。大多数非致命性错误都是暂时的

## 用户标识

1. 口令文件登录项中的用户ID是一个数值，它指向系统标识各个不同的用户。
2. 用户ID不能修改。
3. 如果是root用户，大多数文件权限检测都不再进行
4. 口令文件登录项中也包括用户的组ID，它也是一个数值。这种机制允许同组的各个成员间共享资源
5. 组文件将组名映射为数值的组ID，组文件通常是`/etc/group`
6. 在磁盘上的文件，文件系统都会存储该文件所有者的用户ID和组ID。存储这两个值只需要4个字节
7. 从`4.2BSD`开始就支持了一个用户属于多个组，统称为附属组

## 信号

1. 信号用于通知进程发生了某种情况
2. 进程处理信号的三种方式：
   * 忽略信号。有些信号标识硬件异常，它们会产生不确定的后果，所以不推荐使用这种处理方式
   * 按系统默认方式处理。
   * 捕捉信号。提供一个自编的信号处理函数，对信号进行处理。这样做可以按照我们期望的方式来处理信号
3. 在键盘上有两种方式产生信号，他们都是用于中断当前运行的进程：
   * 中断键`(ctrl + c)`
   * 退出键`(ctrl + \)`
4. 还有一种方式可以产生信号，就是调用kill函数。在一个进程中调用此函数可以给另一个进程发送信号，但是这样做是有限制的：我们必须是接收信号进程的所有者或者超级用户

## 时间值

1. UNIX系统使用两种不同的时间值：
   * 日历时间：`UTC`时间`(1970年1月1日 00:00:00开始，距今的秒数)`。这种时间用于记录文件最近一次的修改时间等等。系统基本数据类型`time_t`用来保存这种时间值
   * 进程时间：`CPU`时间。用来度量进程使用的中央处理器资源。进程时间是以时钟滴答计算。系统基本数据类型`clock_t`用来保存这一时间值
2. 当度量一个进程的执行时间时，Unix系统维护了三个进程时间值:
   * 时钟时间：它是进程运行的时间总量，其值与系统中同时运行的进程数有关。
   * 用户CPU时间：是指执行用户指令所用的时间量
   * 系统CPU时间：是指该进程执行内核程序所经过的时间
3. 用户CPU时间和系统CPU时间统称为CPU时间

## 系统调用和库函数

1. 各个版本的UNIX实现都提供良好定义、数量有限、直接进入内核的入口点，这些入口点被称为系统调用
2. UNIX为每个系统调用在标准C库中设置一个具有相同名字的函数。用户调用该函数，然后改函数又用系统所要求的技术调用相应的内核服务
3. 系统调用一般在`man`手册的第2部分
4. 通用库函数：这些函数与系统函数差不多，它们会调用一个或多个内核的系统调用，但它们并不是内核的入口点。
5. 通用库函数一般在`man`手册的第2部分
6. 对于实现者的角度来看系统调用和库函数有根本区别，但是从用户的角度来看这两者的区别并不重要。
7. 系统调用和库函数之间的差别：
   * 如果可能的话，我们可以替换库函数，但是我们却无法替换系统调用。
   * 系统调用通常提供一种最小接口，而库函数通常提供比较复杂的功能