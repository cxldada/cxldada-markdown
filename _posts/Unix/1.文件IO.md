---
title: 1. 文件I/O
date: 2020-07-14 08:13:25
categories: Unix
tag: io
---

# 文件I/O

## 简介
介绍`open`、`read`、`write`、`lseek`和`close`这几个常用的文件IO函数。这几个文件IO通常被称为不带缓冲的IO(是一个系统调用)。

还会讨论缓冲区长度对这些操作的影响，在使用这些函数的时候要考虑好一个合适的缓冲区长度。
还要介绍一下原子操作的概念，最后再介绍一下`dup`、`fcntl`、`sync`、`fsync`和`ioctl`函数

<!--more-->

## 文件描述符
> 对于内核而言，所有打开的文件都是通过文件描述符引用。文件描述符是一个非负整数。

UNIX系统中的`shell`会把：
* 文件描述符0与`标准输入`关联
* 文件描述符1与`标准输出`关联
* 文件描述符2与`标准错误`关联

*注:(这是很多`unix`程序的使用惯例，与内核无关。但是不遵守这个惯例会有很多麻烦。)*

在`POSIX.1`标准中，对幻数0、1、2进行了标准化：
* `STDIN_FILENO` = 0
* `STDOUT_FILENO` = 1
* `STDERR_FILENO` = 2

*注：定义在`<unistd.h>`中*

文件描述符的变化范围是0~OPEN_MAX-1。(`sysconf(_SC_OPEN_MAX)`函数可以获取)

------

## open和openat函数

> 打开一个文件，返回文件描述符

### 函数定义

```c
#include <fcntl.h>

int open(const char *path,int oflag,...);
// 成功返回文件描述符，出错返回-1

int openat(int fd,const char *path,int oflag,...);
// 成功返回文件描述符，出错返回-1
```

### 参数说明

* `path`：要打开或创建的文件名
* `oflag`：定义了一些选项来控制**打开的方式**。在后文中详细介绍
* 可变参数列表：只有在使用open函数**创建文件**时，用来指定**文件权限**的。

`oflag`参数的可选项很多，但是分为了两类，一类是必填项，一类是可选项。这两者用**逻辑或运算符**连接起来

必填项有：

|     值     |      说明      |         补充          |
| :--------: | :------------: | :-------------------: |
| `O_RDONLY` | 只读的方式打开 | 大多数实现定义为**0** |
| `O_WRONLY` | 只写的方式打开 | 大多数实现定义为**1** |
|  `O_RDWR`  |  读写方式打开  | 大多数实现定义为**2** |
|  `O_EXEC`  |   只执行打开   |                       |
| `O_SEARCH` |   只搜索打开   |                       |

**注意：** 

> 1. 上面必填项中的五个值只能选一个
> 2. 最后一个值(只搜索)有很多系统都还没有支持。它的作用就是在目录打开时**验证它的搜索权限**，后续对此文件描述符操作时，不会再检查搜索权限了，注意是对目录文件

可选项有：

|      值       | 说明                                                         |
| :-----------: | :----------------------------------------------------------- |
|  `O_APPEND`   | 每次进行写操作时，都将内容追加到文件尾                       |
|  `O_CLOEXEC`  | 把`FD_COLEXEC`常量设置为文件描述符标志                       |
|   `O_CREAT`   | 若文件不存在则创建它。使用这个参数时，必须指定最后一个可变参数列表。(可以参考`creat`函数中的[mode_t](#creat函数)参数) |
| `O_DIRECTORY` | 如果`path`引用的不是目录，则出错                             |
|   `O_EXCL`    | 如果同时指定了`O_CREAT`参数，而文件存在则报错。这常用来测试一个文件是否存在，不存在就创建。这使得检测和创建为一个原子操作 |
|  `O_NOCTTY`   | 如果`path`引用的是一个**终端设备**，则不将该设备分配作为此进程的控制终端 |
| `O_NOFOLLOW`  | 如果`path`引用的是一个**符号链接**，则报错                   |
| `O_NONBLOCK`  | 如果`path`引用的是一个FIFO、块特殊文件或者字符特殊文件，则将文件的后续IO操作设置为**非阻塞方式** |
|   `O_SYNC`    | 让每次`write`等待物理IO操作完成，包括由该`write`操作引起的文件属性更新所需的IO |
|   `O_TRUNC`   | 如果文件存在，而且为只写或读写方式打开，则将文件长度截断为0  |
| `O_TTY_INIT`  | 如果打开一个还未打开的终端设备，设置非标准`termios`参数值，使其符合`Single UNIX Specification` |
|   `O_DSYNC`   | 是每次`write`要等待物理IO操作完成，但是如果该写操作并不影响读取刚刚写入的数据，则不需要等待文件属性被更新 |
|   `O_RSYNC`   | 是每一个以文件描述符作为参数运行的`read`操作等待，直至所有对文件同一部分挂起的写操作都完成 |
| 各实现的差异  | 对于`O_SYNC`、`O_DSYNC`和`O_RSYNC`这三个标志，各实现的支持各不相同需要查看相应的文件资料。 |

### 细节说明

由`open`和`openat`函数返回的一定是**最小**的**未使用**的描述符数值。

可以看到`fd`参数把两个函数区分开，有以下几种情况：

1. `path`参数是**绝对路径**时，`fd`参数会被忽略，`openat`函数相当于`open`函数
2. `path`参数是**相对路径**时，
   1. `fd`参数指定了相对路径名在文件系统中的开始地址
   2. `fd`具有特殊值`AT_FDCWD`。这种情况，路径名在当前工作目录中获取。

`openat`函数是`POSIX.1`标准中新增的函数。主要是希望能解决两个问题：

1. 让线程可以使用相对路径名打开文件，而不再是只能相对于当前工作目录。
2. 希望能够解决TOCTTOU(time-of-check-to-time-of-use)问题

> TOCTTOU问题描述：如果有两个基于文件的函数调用，第二个函数调用依赖于第一个函数调用的结果，那么程序就是脆弱的。
> 因为这两个操作不是原子操作，在这两个函数调用之间文件可能发生了变化，这样就导致第一个函数调用的结果不在有效。
>
> 通常用此错误来骗取特殊文件的权限等等。

文件名和路径名截断问题

* 文件名的最大长度可以通过`pathconf(path,_PC_NAME_MAX)`或`fpathconf(fd,_PC_NAME_MAX)`查询
* 在`POSIX.1`标准中，通过`_POSIX_NO_TRUNC`常量来决定是截断过长文件名或路径名，还是返回错误码
  * 查询方式：`pathconf(path,_PC_NO_TRUNC)`或`fpathconf(fd,_PC_NO_TRUNC)`

----

## creat函数

> 创建一个新文件，返回新文件的文件描述符

### 函数定义

```c
#include <fcntl.h>

int creat(const char *path, mode_t mode);
// 成功返回只写方式打开的文件描述符，出错返回-1
```

其实这个函数等效于

```c
int open(path,O_WRONLY | O_CREAT | O_TRUNC,mode);
```

### 参数说明

* `path`：文件名或路径名
* `mode`：新文件的权限(`<sys/stat.h>`)

| `st_mode` |       含义       |
| :-------: | :--------------: |
| `S_IRUSR` |      用户读      |
| `S_IWUSR` |      用户写      |
| `S_IXUSR` |     用户执行     |
| `S_IRGRP` |       组读       |
| `S_IWGRP` |       组写       |
| `S_IXGRP` |      组执行      |
| `S_IROTH` |      其他读      |
| `S_IWOTH` |      其他写      |
| `S_IXOTH` |     其他执行     |
| `S_IRWXU` | 用户读、写、执行 |
| `S_IRWXG` |  组读、写、执行  |
| `S_IRWXO` | 其他读、写、执行 |

### 细节说明

建议使用`open`函数来创建文件，因为`creat`函数有个小麻烦：它创建的文件都是以**只写**的方式打开的。如果我们想要以只读或或读写的方式打开，那么就要先`creat`再`close`然后在`open`，相当的麻烦，所以不如直接使用open函数。

*如果要创建的文件已经存在，`creat`函数会将文件内容截断为0，且文件的访问权限不变*

mode参数指定的权限回收`umake`值得影响

----

## close函数

> close函数，用来关闭一个打开的文件

```c
#include <unistd.h> // 注意头文件不一样
int close(int fd);
// 成功返回0，失败返回-1
```

关闭一个文件时还会释放该进程加载文件上的所有**记录锁**。

当一个进程终止时，内核会**自动关闭**它所打开的**所有文件**。

----

## lseek函数

> 修改当前文件偏移量。当打开一个文件时，除非指定`O_APPEND`选项，否则偏移量被设置为0。

### 函数定义

```c
#include <unistd.h>

off_t lseek(int fd, off_t offset, int whence);
// 成功返回新的当前文件偏移量，出错返回-1
```

### 参数说明

* `fd`：文件描述符
* `offset`：偏移的字节数，与`whence`有关
* `whence`：选项值
  * `SEEK_SET`：从文件开始处开始，偏移`offset`个字节
  * `SEEK_CUR`：从当前偏移量开始，偏移`offset`个字节**(可正可负)**
  * `SEEK_END`：从当前文件长度开始，偏移`offset`个字节**(可正可负)**

### 相关错误码

* 如果文件描述符指向的是一个管道、FIFO或网络套接字，则`lseek`返回-1，并将`error`设置为`ESPIPE`

### 细节说明

* 因为偏移量可能是负值，所以在比较`lseek`的返回值时应当注意，应该判断它是否等于-1，而不是小于0

* `lseek`仅将当前文件偏移量记录在内核中，**不会引起任何IO操作**

* 文件偏移量可以**大于文件的当前长度**，这种情况下，对文件的下次写会加长该文件，并在文件中构成一个**空洞**。位于文件中但没有写过的字节都被读为0。
* 文件的空洞并不要求在磁盘上占用存储区。

----

## read函数
> 从打开的文件中读取数据

### 函数定义
```c
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t nbytes);
// 成功返回读到的字节数，若到文件尾，返回0，出错返回-1
```

### 参数说明

* `fd`：文件描述符
* `buf`：用来存储数据的缓冲区
* `nbytes`：`buf`缓冲区的大小

### 细节说明

有多种情况使实际读到的字节数少于要求读的字节数：

* 读普通文件时，在读到要求的字节数之前已到达了文件尾端。
* 从终端设备读时，通常一次最多读一行
* 从网络读时，网络中的缓冲机制可能造成返回值小于所要求读的字节数
* 从管道或FIFO读时，如若管道包含的字节少于所需的数量，那么`read`将只返回实际可用的字节数
* 当从某些面向记录的设备(如磁带)读时，一次最多返回一个记录
* 当一个信号造成终端，而已经读了一部分数据时

----

## write函数
> 向打开的文件写数据

### 函数定义
```c
#include <unistd.h>

ssize_t write(int fd, const void *buf, size_t nbytes);
// 成功返回已写的字节数，出错返回-1
```

### 参数说明

* `fd`：文件描述符
* `buf`：用来存储数据的缓冲区
* `nbytes`：`buf`缓冲区的大小

### 细节说明

* `write`出错的常见原因是磁盘已写满，或者超过了一个给定进程的文件长度限制

* 如果打开文件时指定了`O_APPEND`选项，则每次写操作前，会将文件偏移量设置到文件结尾处，再写入数据。

----

## 文件共享
> Unix系统支持在不同的进程间共享打开文件。为了说明共享，要先介绍一下内核用于所有IO的数据结构。
> 注意：这里说明的这些数据结构都是概念性的，与特定的实现可能匹配也可能不匹配！

内核使用3中数据结构表示打开的文件，它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响
1. 每个进程在进程表中都有一个记录项，记录项包括一张打开的文件描述符，可以把它看做一个数组，每个描述符占用数组中的一项，与描述符相关联的是：
	* 文件描述符标志(close_on_exec)
	* 指向一个文件只能项的指针
2. 所有打开的文件，在内核中由一张文件表记录着。文件表中的每一项包括：
	* 文件状态标志(读、写、添写、同步和非阻塞)
	* 当前文件偏移量
	* 指向该文件的**v节点**的指针
3. 每个打开的文件或设备都已一个v节点结构。v节点包括了文件类型和对此文件进行各种操作的函数的指针。v节点还包括了文件的i节点(索引节点)。i节点包括了：
	* 文件的所有者
	* 文件长度
	* 指向文件实际数据块在磁盘上所在位置的指针
	* 等等等

大概的数据结构如下图
![file](https://www.cxldada.cn:1122/wp-content/uploads/2020/07/image-1594540770671.png)
 可能有多个文件描述符指向同一个文件表项。

----

## 原子操作
> 原子操作值的是有多步组成的一个操作。如果该操作是原子的操作，则要么执行完所有的操作，要么不执行，不可能只执行所有步骤的一个子集

多个进程同时向一个文件追加数据库时，如果不使用`O_APPEND`标志，可能会造成数据被覆盖的现象。因为修改文件偏移量和写数据是两个操作，在这两个操作之间存在一个时间窗口，当CPU切换切换调度时，就会出现问题。
为了解决这个问题就要用到原子操作的概念，只要把修改文件偏移量和写数据这两个操作合成一个操作就可以了。所以Unix系统提供了`O_APPEND`标志。

### pread和pwrite函数
> Single Unix Specification包括了XSI扩展，该扩展允许原子性的定位并执行IO

#### 函数定义
```C
#include <unistd.h>
ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);
// 返回读到字节数，若到文件尾放回0，出错返回-1

ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset);
// 成功返回已写入的字节数，出错返回-1
```
调用`pread`相当于调用`lseek`后调用`read`，但是`pread`又与这种顺序调用又一下区别：
* 调用`pread`时，无法中断其定位和读操作
* 不更新当前文件偏移量

调用`pwrite`相当于调用`lseek`后调用`write`，但也与他们有类似的区别

注：可以使用[这里的代码](https://github.com/cxldada/Exercise/blob/master/c/preadApwrite.c)验证` pread`和`pwrite`不会修改偏移量

----

## dup和dup函数
> 用来复制一个现有的文件描述符

### 函数定义
```C
#include <unistd.h>
int dup(int fd);
int dup2(int fd,int fd2)
// 成功返回新的文件描述符，出错返回-1
```

由`dup`返回的新文件描述符一定是当前文件描述符中的最小值。

### 参数说明
`dup2`中`fd2`参数用来指定新的描述符的值：
* 如果指定的值已打开，会自动关闭再打开。
* 如果`fd`等于`fd2`，则dup2返回fd2，而不关闭它
* 否则，`fd2`的`FD_CLOEXEC`文件描述符标志就被清除。

关于第三点这里有[测试代码](https://github.com/cxldada/Exercise/blob/master/c/dup_dup2.c)

### 细节说明
因为后面要介绍的`fcntl`也能够像`dup2`一样复制文件描述符，这两个函数并不完全相同，主要有以下几个差别：
1. `dup2`是一个原子操作
2. `dup2`和`fcntl`有些错误码不同

----

## sync、fsync和fdatasync函数
> 传统的Unix系统实现在内核中设有缓冲区高速缓存或页高速缓存，大多数磁盘I/O都滕鸥缓冲区进行。
> 当我们想文件写入数据时，内核通常先将数据复制到缓冲区中，然后排入队列，晚些时候在写入磁盘，这种方式讲座延迟写
> 为了保证磁盘上的实际文件与缓冲区中的内容一致，Unix系统提供了sync、fsync和fdatasync函数

### 函数定义
```C
#include <unistd.h>
int fsync(int fd);
int fdatasync(int fd);
// 成功返回0，出错返回-1

void sync(void);
```

### 细节说明
三个函数的差别：
* `sync`只是就所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写入磁盘操作结束
	* 通常`update`守护进程周期性的调用`sync`函数。
* `fsync`函数只对由文件描述符`fd`指定的一个文件起作用，并且等待写磁盘操作结束
	* `fsync`可用于数据库这样的应用程序
* `fdatasync`函数类似于`fsync`，但它只影响文件的数据部分，而除数据外，`fsync`还会同步更新文件的属性

----

## fcntl函数
> fcntl函数，这是一个功能很丰富的函数

### 函数定义
```C
#include <fcntl.h>
int fcntl(int fd, int cmd, ...);
// 成功依赖于cmd参数(见下)，出错返回-1
```
### 参数说明

* `fd`参数是要进行操作的文件描述符
* `cmd`参数决定了函数的功能，一共有5中功能，对应有11种cmd值：
	* 复制一个已有的文件描述符(cmd = `F_DUPFD` || `F_DUPFD_CLOEXEC`)
		* `F_DUPFD`：复制文件描述符`fd`，新文件描述符作为函数返回值返回。
			* 返回值是尚未打开的描述符中，大于或等于第3个参数值的最小值。
			* 新描述符与`fd`共享同一文件表项，但是新描述符有它自己的一套文件描述符标志，其`FD_CLOEXEC`文件描述符标志被清除
		* `F_DUPFD_CLOEXEC`：复制文件描述符，设置与新描述符关联的`FD_CLOEXEC`文件描述符标志的值，返回新文件描述符
	* 获取/设置文件描述符状态(cmd = `F_GETFD` || `F_SETFD`)
		* `F_GETFD`：对应于`fd`的文件描述符标志作为函数值返回。
			* 当前只定义了一个文件描述符标志`FD_CLOEXEC`
		* `F_SETFD`：对于`fd`设置文件描述符标志，新标志值按第三个参数设置
	* 获取/设置文件状态标识(cmd = `F_GETFL` || `F_SETFL`)
		* `F_GETFL`：获取文件状态标志。就是`open`函数中的[oflag](#open和openat函数)参数
			* 只需要使用`O_ACCMODE`取得访问方式位，然后将结果与前5个值中的每一位进行 比较。
		* `F_SETFL`：将违建描述设置为第3个参数的值。可以设置的标志有：
			* `O_APPEND`
			* `O_NONBLOCK`
			* `O_SYNC`
			* `O_DSYNC`
			* `O_RSYNC`
			* `O_FSYNC`
			* `O_ASYNC`
	* 获取/设置一步I/O所有权(cmd = `F_GETOWN` || `F_SETOWN`)
		* 获取当前接收`SIGIO`和`SIGURG`信号的进程ID或进程组ID
		* 设置接收`SIGIO`和`SIGURG`信号的进程ID或进程组ID
			* 第三个参数是正的指定一个进程ID
			* 第三个参数是负的指向一个进程组ID
	* 获取/设置纪录锁(cmd = `F_GETLK` || `F_SETLK` || `F_SETLKW`)
		* 这三个参数在讲信号的时候回来补充

### 细节说明
* 文件状态值的是文件的打开方式，前面的函数中有说过，文件的打开方式有五个单选项，这五个打开方式是互斥的，所以通过F_GETFL获取到文件状态标示后需要用O_ACCMODE来获取相应文件状态
* 修改文件描述符标志或者文件状态标志时必须要谨慎，不能只是执行F_SETFD或者F_SETFL命令，这个会关闭之前开启的某些标志，所以最好先获取原有标志然后进行与运算符进行设置
* 设置某个标志位，就与相应的标识符进行与操作，关闭某个标志位，则是与上去反的标志位

----

## ioctl函数
> ioctl函数一直是I/O操作的杂物箱，终端I/O是使用ioctl最多的地方

### 函数定义
```c
#include <unistd.h> // system v

#include <sys/ioctl.h> // BSD and linux

int ioctl(int fd, int request, ...);
// 成功与参数有关，出错返回-1
```

### 细节说明

`ioctl`通常需要搭配其他头文件才能使用

|   类别    | 常用名  |       头文件        | `ioctl`数 |
| :-------: | :-----: | :-----------------: | :-------: |
|  盘标号   | DIOxxx  | `<sys/disklabel.h>` |     4     |
|  文件I/O  | FIOxxx  |  `<sys/fileio.h>`   |    14     |
|  磁带I/O  | MTIOxxx |   `<sys/mtio.h>`    |    11     |
| 套接字I/O | SIOxxx  |  `<sys/sockio.h>`   |    73     |
|  终端I/O  | TIOxxx  |  `<sys/ttycom.h>`   |    43     |

## /dev/fd
较新的系统提供名为`/dev/fd`的目录，其目录项为`0,1,2`等文件，打开这些文件，等效于复制文件描述符n。
主要是为了方便`shell`使用，它允许使用路径名作为调用参数的程序，能用于处理其他路径名的相同方式处理标准输入和输出。