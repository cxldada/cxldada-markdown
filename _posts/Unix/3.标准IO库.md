---
title: post
date: 2020-07-18 08:22:51
categories:
tags:
---



# 3. 标准I/O库

标准IO库是一个方便用户使用的库，他让用户不用关心缓冲区、块长度等问题。但是我们还是认真学习标准IO库，因为如果不深入了解标准IO库的某些特点，那么在使用的时候可能会带来一些小麻烦。

<!--more-->

## 流和FILE对象

在之前学习文件IO的时候，可以看得出来所有的IO函数都是以打开的文件描述符为基础来进行操作的。而标准IO库则是围绕着流来进行相关IO操作的。当我们使用标准I/O打开或创建一个文件时，我们已使一个流与一个文件相关联

由于有多种字符集(ASCII、国际字符集等)，每种字符集的字节宽度也是不一样的，有的一个字符占一个字节（单字节），有的一个字符占多个字节（宽字节）。标准IO库为了满足各种字符集，所以流是可以设置单字节或宽字节的。

当以一个流刚被创建的时候是没有定向的。第一次在一个未定向的流上使用单字节I/O函数或是多字节I/O函数的时候，流就会被自动的设置为字节定向或宽定向

----

## 改变流的定向

只有两个函数可以改变流的定义：

* `freopen`函数清除一个流的定向
* `fwide`函数设置一个流的定向

### 函数定义
```c
#include <stdio.h>
#include <wchar.h>

int fwide(FILE *fp, int mode);
// 返回值：
// 若流是宽定向则值 > 0
// 若流是字节定向则值 < 0
// 若流未定向则值 = 0
```

### 参数说明

`mode`参数：

* 如果mode为负值，则将流设置为字符定向
* 如果mode为正值，则将流设置为宽定向
* 如果mode为0，则返回当前流的状态，并不改变流的定向

### 细节说明

* `fwide`函数并不能改变以定向的流。
* `fwide`函数没有出错返回
* 由于没有出错返回，所有一般在使用这个函数前现将`errno`设置为0，然后在调用后来检测`errno`的值

## 标准输入、标准输出和标准错误

每个进程都预定义了3个流，这三个流可以直接使用，他们在`<stdio.h>`中定义为：`stdin`、`stdout`和`stderr`
在文件I/O那边文章中提到过，可以使用`STDIN_FILENO`、`STDOUT_FILENO`和`STDERR_FILENO`这三个文件描述符引用

## 缓冲

为了减少调用`read`和`write`的次数，标准I/O提供了自己的缓冲机制。
一共提供了三种缓冲机制：
1. 全缓冲。只有在写入的数据填满缓冲区的时候才会执行系统I/O操作。
	* 当第一次在一个流上执行I/O操作的时候，相关的标准I/O函数会调用`malloc`函数分配所需的缓冲区。一般全缓冲的缓冲区大小由`<stdio.h>`中的`BUFSIZ`指定。
	* 一般用于处理文件的流
2. 行缓冲。当输入换行符的时候就会执行系统I/O操作。有时就算没有输入换行符，但是缓冲区已满也会触发系统I/O操作。
	* 任何时候只要通过标准I/O库从一个不带缓冲的流，或者一个行缓冲的流得到数据时，就会冲刷所有的行缓冲输出流
	* 几乎所有的终端都是使用行缓冲
3. 不带缓冲。不提供缓冲机制。
	* 标准错误就是不带缓冲的流，这样就可以尽快的将数据显示出来

----

## 冲刷缓冲区

有时希望全缓冲或行缓冲的流在缓冲区还未满的时候就执行系统I/O，可以使用`fflush`函数冲刷流

### 函数定义

```c
#include <stdio.h>

int fflush(FILE *fp);
// 成功返回0，出错返回EOF
```

### 细节说明

如果`fp`参数为`NULL`，那么会冲刷所有已打开的流

## 修改流的缓冲类型

当打开一个流的时候，系统设置默认的缓冲类型，如果我们不喜欢默认的缓冲类型，可以使用下面两个函数修改

### 函数定义

```c
#include <stdio.h>

void setbuf(FILE *restrict fp, char *restrict buf);
int setvbuf(FILE *restrict fp, char *restrict buf, int mode, size_t size);
// 成功返回0，出错返回非0
```

### 参数说明
`setbuf`函数，只有两种情况：
* `buf`不为空，则设置流的缓冲区，但是缓冲区类型由系统定
* `buf`为空，则设置流为不带缓冲的

`setvbuf`函数的`mode`参数：
* `_IOFBF`：全缓冲
	* 如果`buf`非空，这缓冲区长度为`size`
	* 如果`buf`为空，则系统设置默认的大小
* `_IOLBF`：行缓冲
	* 如果`buf`非空，这缓冲区长度为`size`
	* 如果`buf`为空，则系统设置默认的大小
* `_IONBF`：不带缓冲
	* 忽略`buf`和`size·参数

### 细节说明
	* 如果`buf`是在一个函数内定义的自动变量，那么在离开函数的时候应该关闭流，不然离开函数后变量会被清除。
	* 有些系统实现会在缓冲区中存放一些操作信息，所有实际可用的缓冲区大小会小于`size`
	* 最好是使用系统默认分配的缓冲区和缓冲区大小，这样在关闭流的时候，缓冲区也会由系统自动回收

----

## 打开流

有三种方式可以打开流

### 函数定义

```c
#include <stdio.h>
FILE *fopen(const char *restrict pathname, const char *restrict type);
FILE *freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp);
FILE *fdopen(int fd, const char *type);
// 成功返回文件指针，出错返回NULL
```

### 参数说明

`type`参数指定对I/O流的读写方式（`b`表示二进制文件）：
* `r`或`rb`：读打开
* `w`或`wb`：写打开。文件打开时会把文件截断为0。若无文件则可以创建文件
* `a`或`ab`：追加打开。每次写都在文件尾部操作
* `r+`或`r+b`或`rb+`：读写打开
* `w+`或`w+b`或`wb+`：读写打开，打开时会把文件截断为0
* `a+`或`a+b`或`ab+`：读写打开，每次写都在文件尾部。若无文件则可以创建文件

`fdopen`函数的`type`参数有一点区别：所有的截断操作都不会生效。因为是否截断文件要看描述符的打开方式中有没有`O_TRUNC`标志

### 细节说明

这三个函数的区别如下：
1. `fopen`函数打开指定路径的文件
2. `freopen`函数在一个指定的流上打开一个指定的文件。
	* 如果该流已打开，则先关闭。
	* 如果流已定向，则使用`freopen`清除该定向
	* 一般用于将一个指定的文件打开为一个预定义的流。比如把预定义的标准输入、标准输出或标准错误指向指定的文件。
3. `fdopen`函数是把一个文件描述符与一个标准I/O流结合。
	* 常常用于由创建管道和网络通信函数返回的描述符。因为这些特殊类型的文件描述符无法用`fopen`打开

**如果多个进程用标准I/O追加写的方式打开同一个文件时，每个进程的数据都可以正确的吸入文件**

当以读写的方式打开一个文件时，有以下限制：
* 如果中间没有`fflush`、`fseek`、`fsetpos`或`rewind`，则输出后面不能直接跟随输入。
* 如果中间没有`fseek`、`fsetpos`或`rewind`，或者一个输入操作没有到达文件尾端，则在输入操作之后不能直接跟随输出

使用标准I/O函数创建的文件，我们无法确定文件的访问权限位。可以通过`umake`限制这些权限

除非流引用终端设备，否则系统默认流是全缓冲的，如果是终端设备，则流是行缓冲的

## 关闭一个打开的流

```c
#include <stdio.h>

int fclose(FILE *fp);
// 成功返回0，出错返回EOF
```

关闭时会冲洗缓冲中的输出数据。缓冲区的所有数据都会被丢弃。如果是自动分配的缓冲区，系统还会释放改缓冲区

## 读写流

一旦打开了流，就有三种不同类型的非格式化I/O操作：
* 每次处理一个字符的I/O
* 每次处理一行字符的I/O
* 直接I/O或叫二进制I/O

还可以使用两个格式化I/O函数：
* `printf`
* `scanf`

### 每次处理一个字符的I/O

#### 输入函数定义

```c
#include <stdio.h>

int getc(FILE *fp);
int fgetc(FILE *fp);
int getchar(void);
// 成功返回下一个字符，若已达到文件尾或出错，返回EOF
```

#### 细节说明

* `getchar()`相当于`getc(stdin)`。
* `getc`函数可以是宏，而`fgetc`不能是宏，这造成这两个函数的一些区别：
	1. `getc`的参数不能是具有副作用的表达式，因为它会被多次计算
	2. 因为`fgetc`是一个函数，所有可以得到其函数地址，就能当做参数传给其他函数，而`getc`不可以。
	3. 调用`fgetc`的时间比`getc`长，因为调用函数的时间通常比调用宏的时间长

返回值为整数的原因：

	* 这样可以返回所有可能的字符值再加上一个已出错或已达文件尾端的指示值。因为在`<stdio.h>`中`EOF`通常被定义为`-1`

因为返回值包含了到文件尾部和EOF错误，所以可以使用下面两个函数确定到底是哪一种情况

```c
#include <stdio.h>

int ferror(FILE *fp);
int feof(FILE *fp);
// 为真返回非0，为假返回0

void clearerr(FILE *fp);
```

大多数实现中，都会为每个流维护两个标志：
* 出错标志
* 文件结束标志

调用`clearerr`可以清楚这两个标志

#### 回送字符的函数

```c
#include <stdio.h>

ungetc(int c,FILE *fp);
// 成功返回c，出错返回EOF
```

* 回送的字符，在下去读取时会这取出。
* `ungetc`调用成功时，会清除文件结束标志

#### 输出函数定义

```c
#include <stdio.h>

int putc(int c, FILE *fp);
int fputc(int c, FILE *fp);
int putchar(int c);
// 成功返回c，出错返回EOF
```

### 每次一行的IO

```c
#include <stdio.h>

char *fgets(char *restrict buf, int n, FILE *restrict fp);
char *gets(char *buf);
// 成功返回buf，若已到文件尾或出错，返回NULL

int fputs(const char *restrict buf, FILE *restrict fp);
int puts(const char *str);
// 成功返回非负值，出错返回EOF
```

#### 细节说明

* 两个函数都是将数据送入指定的缓冲区，`gets`是从标准输入读取，而`fgets`是从指定的流读取
* `fgets`会保留换行符，`gets`函数不会保留
* `fputs`中的buf要以`null`结尾，但是`null`不会写出。`puts`函数会自动加入一个换行符
* 建议不要使用`gets`函数，因为它无法指定缓冲区的大小，容易造成数据超长

### 二进制I/O

```c
#include <stdio.h>

size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
size_t fwrite(const void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
// 返回读或写的对象数量
```



#### 参数说明

* `ptr`是指向存放结构体的指针
* `size`是单个结构的大小
* `nobj`是需要读取几个结构体
* `fp`就是IO

#### 细节说明

* 当达到文件尾端或出错，`fread`返回的值可能会小于`nobj`，这个时候还是要调用`ferror`或`feof`的函数来判断到底是哪种情况

* 二进制IO只能用于读在同一系统上已写的数据，原因是：
  1. 在一个结构中，同一成员的偏移量可能随编译程序和系统的不同而不同(由于不同的对齐要求)。
  2. 用来存储多字节整数和浮点值的二进制格式在不同搞得系统结构间也可能不同

## 定位流

在UNIX环境中共有三种方式来定位流：

1. `ftell`和`fseek`函数。他们是最早用来定位流的函数，但是它们都假定文件的位置可以存放在一个长整型中
2. `ftello`和`fseeko`函数。这是`Single UNIX Specification`引入的两个函数。他们使用off_t代替了长整型
3. `fgetpos`和`fsetpos`函数。这是`ISO C`引入的。他们使用一个抽象数据类型`fpos_t`记录文件的位置。这种数据可以根据需要定义一个足够大的数。

**如果需要将程序移植到非UNIX系统上运行的话，最好使用`fgetpos`和`fsetpos`函数。**

### ftell系列函数定义

```c
#include <stdio.h>
long ftell(FILE *fp);
// 成功返回当文件文件位置，出错返回 -1L

int fseek(FILE *fp, long offset, int whence);
// 成功返回0，出错返回-1

void rewind(FILE *fp);
// 将流设置到文件的起始位置
```

### 参数说明

- `whence`参数与`lseek`函数相同可以取：`SEEK_SET、SEEK_CUR、SEEK_END`
- 对于一个文本文件来说，如果是用`fseek`的话，`whence`必须是`SEEK_SET`，而且`offset`只能是`0`或`ftell`所返回的值。对于二进制文件就没有这种限

### ftello函数系列

```c
#include <stdio.h>
off_t ftello(FILE *fp);
// 成功返回当文件文件位置，出错返回(off_t)-1

int fseeko(FILE *fp,off_t offset,int whence);
// 成功返回0，出错返回-1

// 下面这两个函数是ISO C提供的。如果想要移植到非unix系统中，最好使用它们
int fgetpos(FILE *restrict fp,fpos_t *restrict pos);
int fsetpos(FILE *fp,const fpos_t *pos);
// 成功返回0，出错返回非0
```





































