---
title: 6.进程控制
date: 2020-07-28 22:06:41
categories: Unix
tags: process
---

# 进程控制

这里记录在Unix系统中创建新进程、执行程序和进程终止相关的内容，说明进程的各种属性。
还记录了解释器文件和`system`函数，最后讲述一下大多数Unix系统所提供的进程会计机制。

# 进程标识

每个进程都有一个非负整型表示的唯一进程ID，虽然是唯一的，但是进程ID是可以复用的。
当一个进程终止后，大多数Unix系统实现延迟复用算法，使得赋予新进程的ID不同于最近终止进程所使用的ID。这防止了将新进程误认为是使用统一ID的某个已终止的先前进程。

系统中有一些专用进程，但是具体细节随实现而不同。大体的内容如下：

1. `ID = 0`的进程：交换进程(swapper)。属于内核的一部分，并不执行任何磁盘上的程序，也被称为系统进程
2. `ID = 1`的进程：`init`进程。
   * 在自举过程结束是有内核调用
   * 该进程的程序文件是`/sbin/init`
   * 它通常需要读取的初始文件为：`/etc/rc*`或`/etc/inittab`和在`/etc/init.d`中的文件
   * 它主要负责在自举内核后启动一个Unix系统，并将系统引导到一个状态，比如多用户状态
   * 该进程绝对不会终止
   * 该进程是一个用户进程，但是它以`root`用户执行
   * 该进程还是所有孤儿进程的父进程
3. `ID = 2`的进程：页守护进程(只在有些实现中)。负责支持虚拟存储器系统的分页操作

## 获取进程标识符的函数

```c
#include <unistd.h>

pid_t getpid(void);
// 返回调用进程的进程ID

pid_t getppid(void);
// 返回调用进程的父进程ID

uid_t getuid(void);
// 返回调用据称的实际用户ID

uid_t geteuid(void);
// 返回调用进程的有效用户ID

gid_t getgid(void);
// 返回调用进程的实际组ID

gid_t getegid(void);
// 返回调用进程的有效组ID
```

### 细节说明

**在这些函数中没有出错返回**

# fork函数

调用`fork`函数创建一个新的进程

## 函数定义

```c
#include <unistd.h>

pid_t fork(void);
// 子进程返回0，父进程返回子进程的ID。出错返回-1
```

## 函数说明

* `fork`函数调用一次，返回两次。
  * 子进程返回值为`0`的原因：一个进程只有一个父进程，所以子进程总是可以调用`getppid`以后的父进程的进程ID
  * 父进程有返回值的原因：一个进程的子进程可以有多个，并且没有一个函数使一个进程可以获得其所有子进程的进程ID
* 进程ID`0`总是由内核交换进程使用，所以一个子进程的进程ID不可能为`0`
* 子进程和父进程继续执行`fork`后的指令，子进程是父进程的副本。
  * 子进程获得父进程的数据空间、堆和栈的副本。
  * 子进程和父进程共享父进程的正文段。可以看上一篇文章中的进程模型
* 由于`fork`之后经常跟随这`exec`函数，所以很多实现使用写时复制技术。
* 父进程的数据段、堆和栈并不是立即创建副本，而是与子进程共享，且内核将它们的访问权限改为只读。
* 如果父进程和子进程中的任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是内存中的一页
* 在`fork`后是父进程还是子进程先执行是确定的，这取决与内核所使用的调度算法
* 在`fork`之后两种处理文件描述符的情况：
  * 父进程等待子进程完成再操作
  * 父进程和子进程个字执行不同的程序段
* 子进程从父进程那里继承的属性有：
  * 打开的文件描述符
  * 实际用户ID、实际组ID、有效用户ID、有效组ID
  * 附属组ID、进程组ID
  * 会话ID
  * 控制终端
  * 设置用户ID标识和设置组ID标识
  * 当前工作目录
  * 根目录
  * 文件模式创建屏蔽字
  * 信号屏蔽和安排
  * 对任一打开文件描述符的执行时关闭(close-on-exec)标识
  * 环境
  * 连接的共享存储段
  * 存储映像
  * 资源限制
* 子进程和父进程之间的区别：
  * `fork`的返回值不同
  * 进程ID不同
  * 两个进程的父进程ID不同
  * 子进程的`tms_utime`、`tms_stime`、`tms_cutime`和`tms_ustime`的值设置为0
  * 子进程不继承父进程设置的文件锁
  * 子进程的未处理闹钟被清除
  * 子进程的未处理信号集设置为空集
* 导致`fork`失败的两种原因：
  * 系统中已经有太多的进程
  * 该实际用户ID的进程总数超过了系统限制(CHILD_MAX)
* `fork`的两个作用：
  * 一个父进程希望复制自己，是父进程和子进程同时执行不同的代码
  * 一个进程要执行一个不同的程序
    * 有些系统将`fork`和`exec`组合成一个操作，称为`spawn`。

## 额外知识点

* `sizeof`和`strlen`的区别：
  * `strlen`返回的长度不包含结束。且`strlen`是一个函数调用
  * `sizeof`返回的长度中包含结束符。对`sizeof`而言，因为缓冲区用已知字符串进行初始化，其长度是固定的，所以在编译时期计算缓冲区长度

# vfork函数

`vfork`和`fork`的函数定义，还有返回值都相同，只是两者的语义不同：

* `vfork`函数创建一个新的进程，而新进程的目的是`exec` 一个新的程序。
* `fork`函数也是创建一个新的进程，但不一定是`exec`一个新的程序

`vfork`并不会将父进程的地址空间完全复制到子进程中，因为马上就要调用`exec`，所以不必要复制。

如果子进程在`exec`前修改了数据，那么返回的结果可能是未知的。

另一个区别是：`vfork`保证子进程先运行，在它调用`exec`或`exit`之后父进程才可能被调度运行。

**如果要写跨平台的程序，则不建议使用`vfork`函数**

