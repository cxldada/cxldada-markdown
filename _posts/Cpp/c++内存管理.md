---
title: c++内存管理
date: 2020-07-05 08:13:25
categories: Cpp
tag: c++
---

# c++内存管理

之前在pocket中收录一篇关于c++内存管理的博客，但是没有怎么仔细研究，只是草草的看来一遍，今天重新来学习一遍，随便做个笔记，方便自己记忆和巩固。

## 1.1 内存五区

在c++中，内存分成5个区域，他们分别是：

1. 堆区：在函数执行时，函数内局部变量的存储单元都在栈上创建，函数执行结束时这些存储单元都会被自动释放掉。栈的内存分配运算内置于处理器的指令集中，效率很高，但是分配的容量有限。

2. 栈区：就是用new分配的内存块，他们的释放编译器不会去管，有我们的程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉这部分内存空间的话，那么在程序运行结束后，操作系统后自动回收。

3. 自由存储区：那些由malloc等分配的内存块，他们和堆是十分相似的，不过他们是由free来释放的

4. 全局/静态存储区：在c++中全局变量和静态变量分配在同一个内存区中

5. 常量存储区：这个存储区比较特殊，这里只存放常量，不允许修改值

## 1.2 区分堆栈

看到new，我们首相想到的是分配了一块堆内存，而指针p则是一块栈内存。可以这样理解：字啊栈内存中存放了一个指向堆内存的指针p。程序会先确定在堆中分配的内存大小，然后调用operator new分配内存，然后返回这块地址的首地址，放入栈中。

### 1.2.1 堆栈的区别：

1. 管理方式不同：对于栈来说，是由编译器自动管理的，不需要程序员控制，对于堆来说，释放工作需要程序员控制的，很容易产生内存泄漏

2. 空间大小不同：堆内存几乎不受限制。栈是有固定空间大小的，可以手动设置编译器的栈空间大小，这个需要自己去找对应的设置项

3. 能否产生碎片：堆内存由于频繁的使用new/delete很容易产生碎片，使程序效率低下，对于栈来讲，这不会出现这个问题

4. 生长方向不同：堆内存的生长方向是向上的，也就是向着内存地址增加的方向生长，栈内存是向下的，也是就是想着内存地址减小的方向增加

5. 分配方式不同：堆内存是动态分配。栈有两种：静态分配和动态分配，今天分配有编译器完成，动态分配由alloca函数进行分配，栈的动态分配是由编译器进行释放的

6. 分配效率不同：栈是机器系统提供的数据结构，计算机会在底层堆栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就是决定了栈的效率很高。堆这是有c/c++库函数提供的，他的机制很复杂，所有效率比栈要低的多

## 1.3 常见内存错误及对策

* 内存分配未成功，却使用了它
> 编程新手容易这种错误。常用的解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NUll)进行检查。

* 内存分配成功，但是尚未初始化就引用它
> 犯这种错误的重要原始有两个：意识没有初始化意识，而好似误以为内存的缺省值是0。所以在使用时一定要初始化后再使用

* 内存分配成功且已经初始化，但是操作越过了内存的边界
> 数组下标很容易出现这种错误。自己多加注意

* 忘记释放内存，造成内存泄漏
> 注意检查new和delete（malloc和free）的次数，保证他们的数量是相同的。

* 释放了内存却还在使用它
> 在释放了内存后，应立即将指针设置为NULL，防止产生野指针