---
title: 重载运算与类型转换
date: 2020-07-04 08:13:25
categories: Cpp
tag: c++
---

# 重载运算与类型转换

重了重载的函数调用运算符operator()之外，其他重载运算符不能含有默认实参

通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符

无法决定运算符定义为成员函数还是普通函数的时候，可以参考一下准则：

* 赋值(=)、下标( [ ] )、调用( ( ) )、和成员访问箭头(->)运算符必须是成员。
* 复合赋值运算符一般来说应该是成员，但非必须，这一点与赋值运算符略有不同
* 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员
* 具有对称性的运算符可能转换任意一端的运算对象，例如算数、相等性、关系和位运算符等，因此他们通常应该是普通的非成员函数

### 重载输入输出运算符

> 第一个参数通常是流的引用，因为我们无法拷贝一个流。
>
> 第二个参数通常是一个类类型的应用。如果是输出运算符则应该是常量引用
>
> 返回值通常是给定的流

输出运算符应该尽量减少格式化的操作。让调用者自己进行输出的格式化是最好的

输入输出运算符，必须是非成员函数

输入运算符必须处理输入可能失败的情况，而输出运算符不用

当读取操作发生错误时，输入运算符应该负责从错误中恢复。最好还能标示出错误

### 算数和关系运算符

> 通常情况下，我们把算数和关系运算符定义成非成员函数以允许左侧或者右侧的运算对象进行转换
>
> 因为这些运算符一般不需要改变运算对象的状态，所有形参都是常量的引用
>
> 返回值一般是一个操作后副本
>
> 如果类同时定义了算数运算符和相关的复合赋值运算符，则通常情况下应该使用复制复制来实现算符运算符

如果存在唯一一种逻辑可靠的<定义，则应该考虑为这个类定义<运算符。如果这个类同时还包含==，则当且仅当<的定义和==产生的结果一致时才定义<运算符。

### 下标运算符

> 表示容器的类型通常可以通过元素在容器中的位置访问元素。
>
> 下标运算符通常时成员函数
>
> 下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端

如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用

### 递增和递减运算符

> 因为递增和递减运算符修改了对象的状态，所有一般情况下我们会定义为成员函数
>
> 定义递增和递减运算符的类应该同时定义前置版本和后置版本。

区分前置和后置版本：

* 前置版本中，函数的参数列表是空。`MyClass operator++();`
* 后置版本中，函数的参数列表中有一个不会被使用的int形参。 `MyClass operator++(int)`

### 成员访问运算符

> 解引用符和箭头运算符的参数列表都为空，而且一般的都是常量函数
>
> 解引用符返回的是该类型的引用
>
> 箭头运算符返回的该类型的指针

### 函数调用运算符

> 函数调用运算符必须是成员函数。
>
> 一个类可以定义多个函数调用运算符，相互之间应该在参数数量或类型上有所区别

### 重载、类型转换与运算符

> 类型转的定义：
>
> ```c++
> operator type() const;
> ```
>
> 其中type表示要转换成的类型。类型转换运算符可以面向任意类型(void除外)进行定义，只要该类型能够作为函数的返回类型。
>
> 类型转换运算符没有显示的返回值，也没有形参，而且必须定义成类的成员函数

---
title: c++运算符重载
date: 2016-11-21 20:48:03
tags: c++
categories: 笔记
---

 c++的操作符重载一直没有学习过，主要是没怎么用。最近在复习所学知识，所以就简单的概括和学习一下操作符重载

 <!-- more -->

重载格式：
	
	函数类型 operator 运算符名称(形参列表)
	{对运算符的重载处理}

重载规则：

* 不允许用户自定义新的运算符，只能对c++中已有的运算符进行重载
* 不能重载的运算符有5个
	* .（成员访问运算符）
	* * (成员指针访问运算符)
	* :: (域运算符)
	* sizeof (长度运算符)
	* ?: (条件运算符)
* 重载运算符不能改变运算符运算对象的个数
* 重载不能改变运算符的优先级
* 重载不能改变运算符的结合性
* 重载运算符不能有默认的参数(不然的话会与第3点矛盾)
* 重载的运算符必须和用户定义的自定义类型的对象一起使用，其参数至少应该有一个是类对象
* 用于类对象的运算符一般必须重载，但有两个列外，运算符“=”和“&”不必用户重载
* 理论上来说，可以将一个运算符重载为执行任意的操作

⚠️注意：应当是重载运算符的功能类似于该运算符作用于标准类型数据时所实现的功能。

运算符重载函数作为类成员函数和友元函数

对运算符重载的函数有两种处理方式：

1. 把运算符重载的函数作为类的成员函数；

		class Complex{
		public:
			Complex operator + (Complex &c2);
		private:
			double real;
			double imag;
		}
		Complex Complex::operator + (Complex &c2){
			return Complex(real + c2.real,imag + c2.imag);
		}
2. 运算符重砸了的函数不是类的成员函数，在类中把它声明为友元函数

		friend Complex operator + (Complex &c1,Complex &c2);
		
		Complex operator + (Complex &c1,Complex &c2){
			return Complex(c1.real + c2.real,c1.imag + c2.imag);
		}
	

⚠️注意：第一种处理方式的列子中只有一个参数，而第二个例子中有两个参数，是因为作为成员函数时，它可以通过this指针自由的访问本类的数据成员，所以可以少写一个函数的参数

重载流插入运算符和流提取运算符

格式如下:
	
	istream & operator >> (istream &,自定义类 &);
	ostream & operator << (ostream &,自定义类 &);