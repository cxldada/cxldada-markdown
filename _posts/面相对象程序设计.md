---
title: 面向对象程序设计
date: 2020-07-16 08:13:25
categories: Cpp
tag: c++
---

# 面向对象程序设计

> 面向对象程序设计基于三个基本概念：
>
> * 数据抽象(封装)：可以将类的接口和实现分离
> * 继承：可以定义相似的类型并对其相似关系建模
> * 动态绑定(多态)：可以在一定程度上忽略相似类型的却别，而以统一的方式使用它们

继承和动态绑定对程序的的编写有两方面影响：

1. 我们可以更容易地定义与其他类相似但不完全相同的新类
2. 在使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略掉他们的区别

## 继承关系

> 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此

关键字virtual只能出现在类内部的声明语句之前不能用于类外部的函数定义

首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员

继承与静态成员：不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例

被用作基类的类：如果我们想将某个类作为基类，则该类必须已经定义而非仅仅声明

阻止继承关系：在类的定义后面加关键字`final`，即表示该类不能作为基类被其他类继承

> 派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类之间不存在这样的转换

## 虚函数

> 一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被他覆盖的基类函数完全一致。
>
> 返回值也必须一致。但是返回值有一个例外的情况，当基类虚函数的返回类型是类本身的引用或指针的时，这条规则无效。例如：D继承自B，则基类B中的虚函数返回类型为B\*(或者B&)，D覆盖基类中的虚函数，那么他的返回值可以是D\*(或者D&)，值不够这样的返回类型要求从D到B的类型转换是可以访问的，也就是public继承

如果虚函数使用默认实参，则基类和派生类中定义的默认实参做好一致。我们通过基类的指针或是引用调用默认实参的虚函数时，不管传入的时派生类还是基类，都将使用基类的默认实参数

如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时改调用将被解析为对派生类版本自身的调用，从而导致无限递归

## 访问控制与继承

protected的性质：派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。

**派生类向基类转换的可访问性：**

* 只有当D共有的继承B时，用户代码才能使用派生类向基类转换；如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换
* 不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说永远都是可访问的
* 如果D继承B的方式是公有或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换

**改变个别成员的可访问性：**我们可以通过`using`声明来改变个别成员的可访问性。派生类只能为那些它能够访问的名字提供`using`声明

默认的继承保护级别：如果使用`class`关键字，则默认私有继承，如果使用`struct`关键字，则默认公有继承

## 继承中的类作用域

当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内

派生类的成员将隐藏同名的基类成员

## 构造函数与拷贝控制

在继承体系中将基类的析构函数定为虚函数是因为，如果基类的析构函数不是虚函数，则delete一个指向派生类的基类指针将产生未定义的行为。

虚析构函数函数将会阻止编译器合成移动操作