---
title: 变量和基本类型
date: 2020-07-01 08:13:25
draft: false
categories: ["C++"]
tag: ["c++"]
author: "cxl"
---

# 变量和基本类型

## 内置类型的最小值限制

>  c++语言规定：
>
> 1. 一个int至少和一个short一样大
> 2. 一个long至少和一个int一样大
> 3. 一个long long至少和一个long一样大

## 字符类型

> 字符类型有三种：char、signed char、unsigned char。但是只有两种表现形式，带符号的和无符号的。因为char类型的表示为其他两种类型中的一种，具体由编译器决定

## 初始化与赋值的区别

> 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，再用一个新值来替代

## 列表初始化(c++11)

> 将列表初始化这种形式用于内置类型的变量时，如果初始值存在丢失信息的风险（比如说精度丢失等情况），则编译器将报错

## 默认初始化

> 内置类型的默认初始值是由它的位置决定的，定义在任何函数体之外的变量被初始化为0，定义在函数内部的内置类型将不被初始化，未被初始化的值时不确定的。

## 变量声明和定义的区别

> 声明：使得名字为程序所知，一个文件如果想要使用别处定义的名字，则必须包含对那个名字的声明。
>
> 定义：负责创建与名字关联的实体

## 引用的特性

> 1. 引用必须在声明时初始化
> 2. 引用绑定了初始对象后，就无法重新绑定另一个对象
> 3. 引用并非对象，它只是一个已经存在的对象所起的另一个名字
> 4. 因为引用不是对象，所以不能定义引用的引用
> 5. 引用只能绑定到对象身上，不能绑定到字面值或某个表达式的计算结果

## 指针与引用的区别

> 1. 指针是对象，允许对指针赋值和拷贝
> 2. 在指针的有效生命周期内，它可以指向几个不同的对象
> 3. 指针不需要在定义是赋初值

## 指针的特性

> 因为引用不是对象，没有实际地址，所以不能定义指向引用的指针
>
> 面对一条比较复杂的指针或者引用声明语句时，从右向左阅读有助于弄清楚它的真实含义

## const的特性

> 1. 默认情况下，const对象仅在文件内有效
> 2. 如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字
> 3. 顶层const：指针本身是个常量
> 4. 底层const：指针所指的对象是一个常量

## constexpr(c++11)

> * 常量表达式三种形式: 字面值，常量值，`constexpr`修饰的值
> * 如果认定一个变量是一个常量表达式，就应该把它声明成``constexpr`类型
> * 一个``constexpr`指针的初始值必须是`nullptr`或者0，或者存储于某个固定位置中的对象（函数体内定义的变量并非存储在一个固定位置，而定义在任何函数题外的对象其地址固定不变）。
> * 限定`constexpr`仅对指针本身有效，与指针所指向的对象无关
> * 用`constexpr`修饰指针，得到是一个顶层`const`指针

## auto类型说明符

> 是由**编译器**负责推导类型，所以定义变量时必须初始化
>
> auto一般会忽略顶层const，保留底层const。如果希望auto推导出顶层const需要显示指出

## decltype类型指示符

> **编译器**将表达式的返回值作为声明符的类型，编译器不会调用表达式
>
> decltype的一些特殊场景：
>
> ```
> int i = 42, *p = &i ,&r = i;
> decltype(r + 0) b; // b是一个int类型，因为表达式(r + 0)的返回值是int
> decltype(*p) c; // 错误，c是一个引用类型，因为指针p是解引用操作，所有返回的类型是引用
> ```
>
> decltype与auto的区别
>
> 1. decltype会保留原表达式的顶层const
> 2. auto只能通过变量的初始值来推导变量的类型，而decltype可以用表达式的结果来推导类型，且不需要强制初始化
> 3. decltype的表达式中是一个不带括号的变量，则变量是什么类型，返回的就是什么类型，如果变量外有一层或多层括号，则变量会为当成一个表达式来处理。变量是一种可以作为赋值语句的左值的特殊表达式，所以加了括号的变量返回的就是一个引用

## 强制类型转换

### dynamic_cast

> 支持运行时类型识别

### static_cast

> 任何具有明确定义的类型转换，只要不包含**底层const**，都可以使用static_cast。
> 还可以把一个较大的算术类型赋值给较小的类型，这样编译器就不会报精度都是的警告。
> 对于编译器无法自动执行的类型转换也非常有用。例如: void*

### const_cast

> 只能改变运算对象的**底层const**，不能改变对象的类型
> 如果对象是一个常量，使用const_cast执行写操作就会产生未定义的后果

### reinterpret_cast

> 通常为运算对象的位模式提供较低层次上的重新解释

## 其他内容

* 定义变量时可以为一个或多个变量赋初值
* **对象**是指一块能存储数据并具有某种类型的内存空间
* 在同一条定义语句中，可以用先定义的变量值去初始化后定义的变量值
* 任何包含了显示初始化的声明即成为**定义**
* c++为标准库保留了一些名字（只是建议，并不强制要求）
  * 用户自定义的标识符中，不能连续出现两个下划线，也不能以下划线紧连大写字母开头
  * 定义在函数体外的标识符不能以下划线开头
* 引用类型的初始值必须与被引用类型相同，但是有两种例外情况：
  * 在初始化**常量引用**时允许使用任意表达式作为初始值，只要该表达式的结果能够转换成引用的类型即可
  * 我们可以把基类指针或引用绑定到派生类对象上
* 如果想在多个文件之间共享`const`对象，必须在变量的定义之前添加`extern`关键字
* 顶层`const`表示指针本身是`const`，底层`const`表示指针所指向的内容是`const`
* 常量表达式是指**值不会改变**并且在**编译过程就能得到计算结果**的表达式

*注意*：

```c++
typedef char *pstring;
const pstring cstr = 0;
// cstr是一个指向char的常量指针（顶层const），不能理解为 const char *cstr = 0;

const pstring *ps;
// ps是一个指针，它的对象是指向char的常量指针，ps本身是底层const，它所指的对象是顶层const指针
```
