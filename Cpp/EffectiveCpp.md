## 尽量使用`const`、`enum`、`inline`代替`#define`

* `#define`是在编译之前进行处理的，编译出错时产生的报错信息可能是已经替换的内容，很难排查错误

* `#define`不能够设置访问权限

* 尽量避免使用宏定义函数，例如：

  ```c++	
  #define CALL_WITH_MAX(a,b) f((a) > (b) ? (a) : (b))
  
  int a = 5, b = 0;
  CALL_WITH_MAX(++a,b); // a被累加2次
  CALL_WITH_MAX(++a,b+10); // a被累加1次
  ```

## 尽可能的使用`const`

* 如果关键字`const`出现在星号的左边，表示被指物是常量，如果出现在星号右边，表示指针自身是常量。如果出现在两边，表示被指物和指针本身都是常量

* 令函数的返回值为`const`可以避免一些错误，例如

  ```c++
  class Rational {...};
  const Rational operator*(const Rational &lhs, const Rational &rhs);
  
  Rational a,b,c;
  if(a * b = c) // 错吧 == 写为 = 就会报错。如果返回值不为const，就不会报错
    ...
  ```

* 两个成员函数如果只是常量性不同，可以被重载

  * 可以使类的`const`对象行为更符合预期
  * 有助于对类接口的理解

* 如果需要在`const`成员函数中改变成员属性，可以将属性定义为`mutable`

* 让`non-const`成员函数调用`const`成员函数来完成同样的工作，避免代码重复

  * 千万不要反过来调用，因为`const`成员函数承诺不会修改成员变量，但是它却调用了`non-const`成员函数，使得承诺无效

  ```c++
  class TextBlock {
  public:
    const char& operator[](std::size_t position) const
    {
      ...;
      return text[position];
    }
    char& operator[](std::size_t position)
    {
      return const_cast<char&>(static_cast<const TextBlock>(*this));
    }
  };
  ```

## 确保对象被使用之前已被正确的初始化

* c++成员初始化次序：
  * 基类初始化先于派生类。
  * 类的成员变量总是以其声明的顺序初始化
* 尽量使用成员初始化列表初始化成员变量。因为在构造函数中的初始化大部分调用的都是变量的赋值运算符，而非直接初始化，效率较低。
* 就地初始化也是晚于成员初始化列表的
* 对于不同编译单元内定义的`non-local static`对象。如果有初始化次序的要求，可以使用单例设计模式

## 编译器默认生成函数

* 如果类中有引用成员变量或者`const`成员变量，则编译器不会生成默认的拷贝赋值运算符

## 为多台基类声明`virtual`析构函数

* 带多态性质的基类应该声明一个`virtual`析构函数。
  * 如果一个类待遇任何`virtual`函数，它就应该有一个`virtual`析构函数
* 如果类的设计不是座位基类使用，或者不是为了具备多态性质，可不应该声明`virtual`析构函数。
  * 如果一个类中含义有虚函数是，则类的结构中就会包含一个`vptr`虚函数指针和一个对应的`vtbl`虚函数表。这会改变类数据大小。

## 别让异常逃离析构函数
* 如果某个操作失败时可能导致异常发生，而又必须要处理该异常，那么这个异常不能从析构函数抛出。因为析构函数抛出异常会带来过早结束程序或发生不明确的行为

## 不要在构造函数和析构函数中调用任何虚函数
* 基类如果在构造函数中调用虚函数，那么在创建派生类时，由于基类的构造函数先于派生类执行，所以基类的构造函数中无法确定调用那个虚函数。析构函数同理

## 在`operator=`中处理自我赋值
* 添加证同测试
  ```c++
  class Test
  {
    Test& Test::operator=(const Test &rhs);
    int *a;
  };
  Test& Test::operator=(const Test &rhs)
  {
    if(this == &rhs) return *this;
    delete a;
    a = new int(rhs.a);
    return *this;
  }
  ```
* 异常安全性
  ```c++
  Test& operator=(const Test &rhs)
  {
    int *tmp = a;
    a = new int(rhs.a);
    delete tmp;
    return *this;
  }
  ```
* 使用`swap`，不推荐

## 复制对象时不要忘记每个成员变量
* 派生类在实现自己的拷贝构造函数和拷贝赋值运算符时，不要忘记每一个成员，最重要的是记得调用相应基类的拷贝控制函数

## 使用对象管理资源
* 使用对象管理所分配的资源，在对象销毁时自动归还资源
* RAII：获取资源的时候就是初始化的时候（Resource Acquisition Is Initialization）
* 在编写自己的资源管理类时要注意类的拷贝行为，共有一下几种处理方式
  * 禁止复制
  * 使用引用计数，当计数为0时销毁对象，类似于`shared_ptr`
  * 复制底层资源，深拷贝
  * 转移地政资源的拥有权，类似于`unique_ptr`
* 在资源管理类中提供对原始资源的访问，有两种形式：
  * 显示，提供一个获取资源的接口
  * 隐士，重载`operator()`运算法。但是在赋值是会有隐患
* 以独立语句将`newed`对象Cyrus智能指针内，如果不这样做，一旦异常抛出，有可能导致难以察觉的资源泄露

##  设计class犹如设计type
在设计一个class时，应考虑一下问题:
* 新type的对象应该如何被创建和销毁 
* 对象的初始化和对象的赋值该有什么样的差别
* 新type的对象如果被`pass by value`，意味着什么？这决定了如何实现拷贝构造函数
* 什么是新type的合法值
* 新type需要配合某个继承体系吗
* 新type需要什么要的转换？决定了需要实现那些类型转换函数
* 什么样的操作符和函数对此新type而言是合理的
* 什么样的标准函数应该驳回
* 谁该取用新type的成员
* 什么是新type的未声明接口
* 新type有多么一般化？ 是一个`class`还是一个`class template`
* 是否需要一个新type？是否可以使用`non-member`函数或`template`函数实现

## 尽量以`pass by reference to const`替换`pass by value`
* 对于自定义定义类型使用这条建议可以防止对象切割问题
* 对于内置类型和STL中的迭代器以及函数对象，可以使用`pass by value`
  * 因为他们足够小
  * 或者这些类型的设计者在设计这些类型时就是保证了对象切割问题，以及对象大小的问题，并提供了一个高效的初始化操作。

## 不要返回一个`reference`或`pointer`

## 将成员变量声明为`private`
* 这样做可以赋予客户访问数据的一致性(全部都用函数的方式调用)，可以细微划分访问权限，允诺约束条件获得保证，并提供`class`作者以充分的实现弹性
* `protected`并不比`public`更具封装性

## 使用`non-member non-friend`函数替换`member`函数
* 这样做可以增加封装性、包裹弹性和机能扩充
* 将`class`定义在命名空间中，将相关便利的函数分成多个部分存储在不同的头文件中，方便用户包含编译。

## 如果某个函数的所有参数都需要能够进行类型转换，那么这个函数必须是个 `non-member`函数

## `swap`函数的设计
* 提供一个`public swap`成员函数，让它高效的置换你的数据。并且绝不该抛出异常
* 在你的`class`或`template`所在的命名空间内提供一个`non-member swap`，并令它调用上述`swap`成员函数
* 如果写的是一个`class`而不是`template`，为你的`class`特化`std::swap`。并令它调用 `swap`成员函数
* 最后，如果你调用`swap`，请确定包含一个`using`声明式，以便让`std::swap`在你的函数内曝光可见，然后不加任何命名空间修饰符，调用`swap`

## 尽可能延后变量的定义式出现。
* 这样做可以增加程序的清晰度并改善程序效率

## 尽量少做转型动作
* `c++`中类型转换的写法：
  * 两种旧式转型写法：
    1. `(T)expression`
    2. `T(expression)`
  * 四种新式转型写法：
    1. `const_cast<T>()`: 通常用来将对象的常量性移除
    2. `dynamic_cast<T>()`: 用来执行安全向下转型，也就是用来决定某对象是否归属于继承体系中的某个类型。他是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作
    3. `reinterpret_cast<T>()`: 指定低级转型，实际动作取决于编译器，意味着不可能移植
    4. `static_cast<T>()`: 用来强迫隐式转换
* 如何可能，尽量避免使用`dynamic_cast<T>()`。
  * 可以将调用函数想基类移动成为`virtual`函数

## 尽可能的使函数异常安全
* 满足异常安全有两点要求：
  1. 不泄露任何资源
  2. 不允许数据被破坏
* 异常安全的函数提供以下三种保证之一：
  1. 基本承诺：如果异常抛出，程序内的任何事物仍然保持在有效状态下。数据可以指向缺省值或者继续持有原数据。总之，用户需要调用某个成员函数才能知道数据的真实状态
  2. 强烈保证：如果异常抛出，程序状态不改变。数据在抛出异常后，会恢复到调用函数之前的状态
  3. 保证不抛出异常，承诺绝不抛出异常，应为它们总是能够完成它们原先承诺的功能

## 关于`inline`函数
* 内联函数的整体观念是，将对次函数的每一个调用都以函数本体替换之。这样会增加目标码的大小
* `inline`是个申请，编译器可以选择忽略
* 当以函数指针的方式调用内联函数时，编译器可以会产生一个函数本体。
* 如果程序库内的一个`inline`函数发生了修改，那么所在调用该函数的客户端程序都需要重新编译，而`non-inline`函数只需要重新链接就好了
* 如果`friend`函数也被定义在`class`中，那么它也是隐喻的`inline`
* 大部分的调试器对`inline`函数都束手无策
* 修改内联函数会使得所有调用者都要重新编译
* 80-20法则：平均而言一个程序往往80%的执行时间花费在20%的代码上。这提醒开发者，你的目标是找出这可以有效增进程序整体效率的20%的代码

## 将文件间的编译依存关系降至最低
* 编译依存性最小化的本质：现实中让头文件尽可能的自我满足，万一做不到，则让他与其他文件内的声明式相依
* 未声明式和定义式提供不同的头文件。可以参考`iosfwd`文件
* 两个重要的手段是`Handle classes`和`Interface classes`

## `public`继承
* `public`主张，能够施加到`base class`身上的每件事，也可以施加到`derived class`身上

## 可以为纯虚函数提供定义
* 这可以避免有些时候派生类没有重载虚函数而导致使用了基类的函数实现。
* 两个`class`设计者常见的错误：
  1. 将所有的函数都声明为非虚函数。
  2. 将所有的函数都声明为`virtual`。除了接口类以外

## `virtual`函数的替代方案
* 使用`non-virtual interface`手法。的非虚函数中调用虚函数，子类只需要实现被调用的虚函数就可以。
  * 这样做可以让基类决定调用的时机，而派生类决定调用时做的事
* 使用函数指针
* 使用函数对象
* 使用`strategy`设计模式。将函数替换为另一个继承体系内的虚函数
* 绝对不要重新定义基类的`non-virtual`函数

## 绝不重新定义继承而来的缺省参数值
* 因为缺省参数值都是静态绑定的，而`virtual`函数是动态绑定的
* 如果基类需要一个缺省值，那么可以提供一个非虚函数，调用一个虚函数，然后给非虚函数的参数值设置默认参数

## 明智而审慎的使用`private`继承
* 如果`classes`之间的继承关系是`private`，那么编译器不会自动将一个`derived class`对象转换成一个`base class`对象
* 由`private base class`继承而来的所有成员，在`derived class`中都会变成`private`属性
* `private`继承意味着只有实现部分被继承，接口部分应略去

## 明智而审慎的使用多重继承
* 使用`virtual`继承的那些`classes`所产生的的对象往往比用`non-virtual`继承的兄弟们体积大，访问`virtual base class`的成员变量时，也比访问`non-virtual base classes`的成员变量速度慢
* 使用`virtual`继承的建议：
  1. 非必要不要使用`virtual`继承
  2. 如果必须使用，尽可能避免在其中放置数据
 
## 了解隐式接口和编译期多态
*  `classes`和`template`都支持接口和多态
  * 对`classes`而言接口是显式的，以函数签名为中心。多态则是通过`virtual`函数发生在**运行期**
  * 对`template`而言接口是隐式的，奠基于有效表达式。多态则是通过`template`具现化和函数重载解析发生于**编译期**

## 了解`typename`的双重定义
* 任何时候当你想要在`template`中指涉一个嵌套从属类型名称，就必须在紧邻它的前一个位置加上关键字`template`
  * 但是不能在`base class list`和`member initialatin list`内以它作为`base class`修饰符

## 处理模板化基类内的名称
* 可在`derived class template`内通过`this->`指定`base class templates`内的成员名称，或者使用`using`声明，或者用基类作用域调用基类方法

## 运用成员函数模板接受所有兼容类型
* 如果声明了成员函数模板用于泛化copy构造或泛化赋值操作，还是需要声明正常的copy构造函数和拷贝赋值构造函数