---
title: 1.简单动态字符串
date: 2020-07-19 18:12:36
draft: false
categories: ["Redis"]
tag: ["sds"]
author: "cxl"
---

# 简单动态字符串

redis没有使用C语言中的字符串，而是自己构建了一个叫做简单动态字符串(simple dynamic string，SDS)的抽象类型。



```c
typedef char *sds;

struct sdshdr {
    int len; // buf中使用的长度
    int free; // buf中未使用的长度
    char buf[]; // 数据
};

/*
创建了一个sds字符串s后，其实s指向的是buf的地址
为了获取sdshdr结构，只要使用s减去sdshdr的大小就定位到了sdshdr的位置

sds s;
struct sdshdr *sh = (void*)(s-sizeof(struct sdshdr));

很巧妙的结构设计，指针玩儿的贼6
*/
```

# 结构说明

`sds`结构与C字符串的相同处

* `sds`和C语言中的字符串一样也是以`null`字符作为结尾
* 结尾的`null`不算在字符长度`len`中
* 遵循`null`结尾的好处是可以重用一部分C字符串函数库的函数

不同处：

* `sds`可以常数时间内获取字符串的长度和剩余空间
* `sds`不会出现缓冲区溢出的问题
  * 因为`sds`记录的长度信息，所以在做处理时会检测空间是否足够
* `sds`可以动态的修改空间大小。
* `sds`二进制安全

# 动态空间分配策略

`sds` 可以动态的调整数据空间的大小，为了减少内存重分配和数据拷贝的次数，`sds`采用空间预分配和惰性空间释放两种优化策略。



## 空间预分配

当对一个`sds`字符串进行处理时，可用空间不够了，需要扩充时，`sds`会对空间进行重新分配。不仅分配所需要的空间大小，还会分配额外的空间，以备后用。

额外空间的大小有以下策略：

* 如果修改后`sds`的长度`len`小于`1MB`，那么额外空间的大小`free`和长度`len`一样
* 如果修改`sds`的长度`len`小于`1MB`，那么额外空间的大小`free`等于`1MB`

通过这样的分配策略可以减少内存重分配和数据拷贝的次数。



## 惰性空间释放

当`sds`的`API`需要缩短数据时，程序并不会马上调整空间大小，而是使用降低`free`字段的值，来记录剩余可用空间的大小，从而达到对空间的调整。

这样做的好处是省去了缩小数据长度的开销，同时也为再次扩展`sds`数据长度时做了优化。

当然提供了真正释放`sds`空间的`API`，所以不用担心会造成内存浪费



# 二进制安全

C语言中的字符串不能包含多个空字符，否则在遇到第一个空字符的时候就被认为结束了。二进制中可能会存在很多空字符，所以C语言中的字符串并不是二进制安全的。

`sds`提供的所有`API`都是二进制安全的。在`sds`结构中使用`buf`字段来存储二进制数据，用`len`记录数据长度，所以即使提前遇到空字符，只要未达到指定的长度，数据都被认为是有效的。



# 代码实现

`sds`相关的`API`实现

## 创建一个SDS

